% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/netCallStatic.R
\name{netCallStatic}
\alias{netCallStatic}
\title{Call static method}
\usage{
netCallStatic(
  typeName,
  methodName,
  ...,
  wrap = FALSE,
  out_env = parent.frame()
)
}
\arguments{
\item{typeName}{Full .Net type name}

\item{methodName}{Method name to call}

\item{...}{Method arguments}

\item{wrap}{Specify if you want to wrap \code{externalptr} .Net object into \code{NetObject} \code{R6} object. `FALSE`` by default.}

\item{out_env}{In case of .Net method with \code{out} or \code{ref} argument,
specify on which \code{environment} you want to out put this arguments.
By default it's the caller \code{environment} i.e. \code{parent.frame()}.}
}
\value{
Returns the .Net result.
If a converter has been defined between the .Net type and a \code{R} type, the \code{R} type will be returned.
Otherwise an \code{externalptr} or a \code{NetObject} if \code{wrap} is set to \code{TRUE}.
}
\description{
Call a static .Net method for a given .Net type name
}
\details{
Call a static method for a given .Net type name.
Ellipses has to keep the .net arguments method order, the named arguments are not supported yet.
If there is conflicts with a method name (many definition in .Net), a score is computed from your argument's
order and type. We consider a higher score single value comparing to collection of values.

If you decide to set \code{wrap} to \code{TRUE}, the function returns a \code{NetObject} instead of a raw \code{externalptr}.
To remind an \code{externalptr} is returned only if no one native converter has been found.
The \verb{NetObject R6} object wrapper can be an inherited \code{R6} class. For more details about
inherited \code{NetObject} class please see \code{netGenerateR6} function.

The \code{out_env} is usefull when the callee .Net method has some \code{out} or \code{ref} argument.
Because in .Net this argument set the given variable in the caller scope. We reflect this
mechanism in R. By default the given varable is modify in the parent \verb{R environment} which means
the caller or \code{parent.frame()}. You can decide where to redirect the outputed value
by specifying another \code{environment}. Of course be sure that the variable name exists in this
targetd \code{environment}.
}
\examples{
\dontrun{
library(sharper)

pkgPath <- path.package("sharper")
f <- file.path(pkgPath, "tests", "AssemblyForTests.dll")
netLoadAssembly(f)

type <- "AssemblyForTests.StaticClass"
netCallStatic(type, "CallWithInteger", 2L)
netCallStatic(type, "CallWithIntegerVector", c(2L, 3L))

# Method selection single value vs vector values
netCallStatic(type, "SameMethodName", 1.23)
netCallStatic(type, "SameMethodName", c(1.24, 1.25))
netCallStatic(type, "SameMethodName", c(1.24, 1.25), 12L)

# wrap result
x <- NetObject$new(ptr = netNew("AssemblyForTests.DefaultCtorData"))
clone <- netCallStatic(type, "Clone", x, wrap = TRUE)

# out a variable
out_variable = 0
netCallStatic(type, "TryGetValue", out_variable)
}
}
