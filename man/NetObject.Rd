% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/netObject.R
\name{NetObject}
\alias{NetObject}
\title{NetObject class}
\description{
NetObject R6 class to wrap an `externalptr``which represents a .Net object.
}
\examples{
\dontrun{
library(sharper)
package_folder <- path.package("sharper")
netLoadAssembly(file.path(package_folder, "tests", "AssemblyForTests.dll"))

x <- netNew("AssemblyForTests.DefaultCtorData")
object <- NetObject$new(ptr = x)
object$set("Name", "My Name")
object$get("Name")
}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{Ptr}}{\code{externalptr} of the wrapped .Net object}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{NetObject$new()}}
\item \href{#method-get}{\code{NetObject$get()}}
\item \href{#method-set}{\code{NetObject$set()}}
\item \href{#method-call}{\code{NetObject$call()}}
\item \href{#method-as}{\code{NetObject$as()}}
\item \href{#method-getType}{\code{NetObject$getType()}}
\item \href{#method-print}{\code{NetObject$print()}}
\item \href{#method-clone}{\code{NetObject$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Create a new NetObject.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$new(typeName = NULL, ptr = NULL, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{typeName}}{.Net full type name.}

\item{\code{ptr}}{\code{externalptr} of the .Net object.}

\item{\code{...}}{Property setters}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
You can use 2 ways to instanciate a .NetObject.
If you specify the \code{externalptr} through the \code{ptr} parameter,
this pointer will be wrapped and stored into the \code{Ptr} active binding.
Otherwise if your .Net class has a default constructor you can specify the \code{typeName}
as \code{netNew(typeName)} does.

The ellipsis parameter can be use to setup the .Net properties. This feature
works with both building ways.
You can use it as follow \code{o <- NetObject$new(typeName, Name = "My name", Id = 1L)}
}

\subsection{Returns}{
A new wrapped .Net object.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get"></a>}}
\subsection{Method \code{get()}}{
Gets a property value
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$get(propertyName, wrap = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{propertyName}}{Property name}

\item{\code{wrap}}{Specify if you want to wrap a \code{externalptr} .Net object into a \code{NetObject} object. `TRUE`` by default.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Allows you to get a property value for a .Net object.
The result will be converted if the type mapping is defined. All native C# types are mapped to R types
but you can define custom converters in C# for that see the C# \code{RDotNetConverter} class.

By default \code{wrap} is set to \code{TRUE}. If there is no native convertion found between .Net type and R type,
the result is wrapped into \code{NetObject} instance.
A best \code{R6} type can be chosen if this type exists. This \code{R6} class has to inherit from \code{NetObject}
and has to have the same name than the C# class. You can generate automatically this inherited class.
For more details about this feature please see the \code{netGenerateR6} function.
If you prefer get a raw \code{externalptr} to the .Net object,

This function is aquivalent to call \code{netGet(o$Ptr, propertyName)}
}

\subsection{Returns}{
Returns the .Net property value.
If a converter has been defined between the .Net type and a \code{R} type, the \code{R} type will be returned.
Otherwise an \code{externalptr} or a \code{NetObject} if \code{wrap} is set to \code{TRUE}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set"></a>}}
\subsection{Method \code{set()}}{
Sets a property value
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$set(propertyName, value)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{propertyName}}{Property name.}

\item{\code{value}}{value to set}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Allows you to set a property value of a .Net object.
The input value will be converted from R type to a .Net type.

If the property value isn't a native C# type or a mapped conversion type,
you have to use an \code{externalptr} on .Net object or a \verb{NetObject R6} instance.

You can define custom converters in C# for that see \code{RDotNetConverter} C# class.

This function is aquivalent to call \code{netSet(o$Ptr, propertyName, value)}.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-call"></a>}}
\subsection{Method \code{call()}}{
Call a .Net method member.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$call(methodName, ..., wrap = TRUE, out_env = parent.frame())}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{methodName}}{Method name}

\item{\code{...}}{Method arguments}

\item{\code{wrap}}{Specify if you want to wrap \code{externalptr} .Net object into \code{NetObject} \code{R6} object. `TRUE`` by default.}

\item{\code{out_env}}{In case of a .Net method with \code{out} or \code{ref} argument is called,
specify on which \code{environment} you want to out put this arguments.
By default it's the caller \code{environment} i.e. \code{parent.frame()}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Call a method member for a given .Net object.
Ellipses has to keep the .Net arguments method order, the named arguments are not yet supported.
If there is conflicts with a method name (many definition in .Net), a score is computed from your argument's
order and type. We consider a higher score single value comparing to collection of values.

If you decide to set \code{wrap} to \code{TRUE}, the function returns a \code{NetObject} instead of a raw \code{externalptr}.
To remind an \code{externalptr} is returned only if no one native converter has been found.
The \verb{NetObject R6} object wrapper can be an inherited \code{R6} class. For more details about
inherited \code{NetObject} class please see \code{netGenerateR6} function.

The \code{out_env} is usefull when the callee .Net method has some \code{out} or \code{ref} argument.
Because in .Net this argument set the given variable in the caller scope. We reflect this
mechanism in R. By default the given varable is modify in the parent \verb{R environment} which means
the caller or \code{parent.frame()}. You can decide where to redirect the outputed value
by specifying another \code{environment}. Of course be sure that the variable name exists in this
targetd \code{environment}.

This function is aquivalent to call \code{netCall(o$Ptr, methodName)}.
}

\subsection{Returns}{
Returns the .Net result.
If a converter has been defined between the .Net type and a \code{R} type, the \code{R} type will be returned.
Otherwise an \code{externalptr} or a \code{NetObject} if \code{wrap} is set to \code{TRUE}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-as"></a>}}
\subsection{Method \code{as()}}{
Cast the current R6 class to another.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$as(className)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{className}}{\code{R6} class name to cast.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If the \code{R6} \code{className} already exists the wrapped \code{externalptr}
which represents a .Net object will be transfer to a new \code{R6}
instance of type \code{className}.
}

\subsection{Returns}{
a new \code{R6} instance of type \code{className}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-getType"></a>}}
\subsection{Method \code{getType()}}{
Gets \code{NetType} description of wrapped .Net object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$getType()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\subsection{Method \code{print()}}{
Print the object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$print(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{NetObject$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
